---
title: "usePaginatedData：优雅地管理分页数据"
publishedAt: "2025-10-02"
tag: "React Deep Dive"
image: "/images/blogs/react-deep-dive-cover.jpg"
---

## 背景

在开发杭电吉协小程序的时候，工程中有很多进行数据分页获取的代码。这些代码的处理逻辑相对复杂，使得本来就包含很多函数和状态的页面组件代码可读性进一步降低。好在这些逻辑遵循同一种模式，能够对其抽象后进行封装。

### 微信云开发的限制

在小程序中，往往会有使用列表对数据进行展示的场景。如果你使用腾讯云（Tencent CloudBase，下文简称为 TCB）进行开发，同时没有使用云函数，那么就会面临每次 GET 请求获取数据的最大数量为 20 条这个限制。

这和使用云函数或自有后端服务不同的是，你不能在请求的时候使用 pageSize 参数来自定义获取分页数据的数量；20 条数据是 TCB 能给你返回的最大数据量。

在我对项目的规划中，暂时没有使用云函数来扩展接口能力的打算，因为项目前期的重点是功能的快速开发。因此，我就把 20 条数据作为项目一个“约定”好的数据分页上限，在此基础上进行业务逻辑的开发。

### 重复的状态管理逻辑

数据分页在前端需要重点管理的状态位有：

- `data[]` ：获取到的数据列表
- `hasMore` ：是否有更多数据；用于决定列表底部应该展示 ”获取更多数据”的 CTA 按钮，还是 “已加载全部数据” 的文案
- `pageIndex` ：当前数据页码；在发送请求的时候，需要知道获取哪一页的数据

在原始的代码中，我会在每个页面中都分别声明了一遍相同结构的状态；以及写了特化的函数，来进行数据的获取和状态的设置。

比如说在乐队列表界面中，我声明的状态是这样的：

```tsx
interface BandsData extends PaginatedState {
  bands: Band[];
}

const DefaultBandsData: BandsData = {
  bands: [],
  pagination: {
    hasMore: false,
    pageIndex: 0,
  },
};

const [bandsData, setBandsData] = useState<BandsData>(DefaultBandsData);
```

尽管这种状态的结构是合理的。但换了一个页面之后，又要对同样结构的状态进行声明、类似的接口进行定义；就会发现其实是在对代码进行复制黏贴操作。

除了状态之外，数据获取函数是这样的：

```tsx
const fetchBands = async (auto = false) => {
  let fetchedData;

  // 从当前的状态中获取数据分页的页数
  const pageIndex = auto ? bandsData.pagination.pageIndex : 0;

  // 调用API请求函数
  const status = activeBandTabKey.replace("Bands", "") as BandStatus;
  fetchedData = await getBandsByStatus({ status, pageIndex });
  const { data: fetchedBands, hasMore } = fetchedData;

  // 更新状态
  setBandsData((prev) => {
    const bands = auto ? [...prev.bands, ...fetchedBands] : fetchedBands;
    return { bands, pagination: { hasMore, pageIndex: pageIndex + 1 } };
  });
};
```

这里同样也能发现一个规律，就是除了进行 API 请求的函数，在不同的界面中会有差异之外；状态的更新，pageIndex 的判断，都遵循了一个固定的模式。

## usePaginatedData 的设计思路

为了能够复用这种数据分页获取的逻辑，第一直觉就是将其封装成一个函数。但由于这里的可复用逻辑中还包含了一个固定范式的 React 状态，因此最好的做法就是写一个能够管理 state 生命周期的 custom hook。

### 状态

和之前 tab 页面组件中特化的状态声明类似；在自定义钩子中，将列表数据使用更具有通用性语义的 `data` 字段来存储。这里为了保留类型安全特性和代码字段提示，通过传入的一个泛型定义数组的类型。

```tsx
interface PaginatedData<T> {
  data: T[];
  pagination: {
    hasMore: boolean;
    pageIndex: number;
  };
}
```

在 tab 页面组件中解构使用时，可以给 data 变量进行重命名操作，增强代码可读性。

```tsx
const { data: bandsData } = usePaginatedData<Band>();
```

### 包含业务逻辑的回调函数

除了状态之外，分页数据处理的另一核心在于数据获取。这部分逻辑并不应该与 `usePaginatedData` 这个钩子进行耦合（比如说钩子初始化的时候传入某些参数，告诉钩子要获取什么实体的数据），因为数据分页给业务逻辑提供的是一种支撑作用。

因此分页钩子提供的接口，应该是一种能够对外部定义的函数进行调用，并处理其返回数据的能力。与这种能力相对应的，其实就是回调函数。

注意，此处回调函数不应该作为钩子初始化的参数传入，而是应该在钩子内部定义一个 获取数据 + 更新状态的函数，这个函数的参数接收一个回调函数，以保证灵活性，同时避免状态的意外重置。

```tsx
const fetchPaginatedData = async (params: FetchPaginatedDataParams<T>) => {
  const { autoPagination = false, fetchFn } = params;

  const pageIndex = autoPagination ? paginatedData.pagination.pageIndex : 0;

  // `fetchFn` 通常包含 API 请求函数
  const fetchedData = await fetchFn(pageIndex);
  const { data, hasMore } = fetchedData;

  setPaginatedData((prev) => {
    const newData = autoPagination ? [...prev.data, ...data] : data;
    const pagination = { hasMore, pageIndex: pageIndex + 1 };
    return { data: newData, pagination };
  });
};
```

这个函数作为钩子的返回对象之一，在初始化时通过解构获取到；这样就能够在保证 `usePaginatedData` 自治理内部状态的同时，使页面业务逻辑相关的代码能够轻松地通过调用 wrapper 函数获取最新的状态数据，而不用担心如何进行复杂的状态更新操作逻辑。

```tsx
const { data: bandsData, fetchPaginatedData } = usePaginatedData<Band>();

const fetchBands = (autoPagination = false) => {
  return fetchPaginatedData({
    autoPagination,
    fetchFn: (pageIndex: number) => {
      const status = activeBandTabKey.replace("Bands", "") as BandStatus;
      return getBandsByField({
        mode: "paginated",
        pageIndex,
        conditions: [{ name: "乐队状态", field: "status", cmd: _.eq(status) }],
      });
    },
  });
};

// 监听乐队Tab类型的变化，更新乐队数据
useEffect(() => {
  fetchBands();
}, [activeBandTabKey]);
```

### autoPagination 的作用是什么？

除了划动到列表底部加载更多数据之外，为了保证数据的实时性，页面还支持：

- 上拉释放刷新，加载最新的数据
- 切换到别的 Tab 再切回当前的 Tab 时，需要重新获取最新的数据

在这两个场景下，代码逻辑应该是重新获取第一分页的数据，而非接着获取下一页的数据。

因此这里默认的逻辑是 `autoPagination = false` 的意思就是，默认行为是刷新获取第一页的数据，而非获取分页的数据。当开启 `autoPagination` 时，`usePaginatedData` 钩子内部就会根据数据获取函数返回 `hasMore` 字段，结合当前状态中的 `pageIndex` ，自动管理页码索引，在下一次请求的时候获取下一分页的数据。

## 总结

之前使用 custom hook，经常是为了将 UI 代码与业务逻辑代码进行分离，增强代码的可读性；实际上并没有什么可复用性。

但是在该分页数据管理的场景下，`usePaginatedData` 这个自定义钩子就提供了非常明显的可复用性价值，大幅提升了代码质量（目前项目中已经有 3 处用到了这个钩子，使用起来简洁方便）。
