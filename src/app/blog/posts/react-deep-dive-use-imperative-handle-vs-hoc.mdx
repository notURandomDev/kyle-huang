---
title: "useImperativeHandle vs 复合组件"
publishedAt: "2025-03-30"
tag: "React Deep Dive 系列"
image: "/images/gallery/react-deep-dive-cover.jpg"
---

## 使用场景

在聊天界面的父组件中，有以下子组件：

- 聊天气泡列表：渲染代价高昂
- 自定义 TextInput 输入控件
- 用于发送消息的按钮

如果将 textInputValue 的 state 放在父组件中，并通过参数传给自定义的输入框组件；会导致用户每输入一个字，都会使整个父组件重新渲染。

尽管渲染成本高昂的聊天气泡列表，已经使用 memo 进行优化；但是父组件中还是有很多函数（用于网络请求以及初始化），在父组件重新渲染的时候也会被重新定义。

这些函数理论上是可以用 useCallback 来进行缓存。但问题是函数的数量很多，同时也不可能每写一个函数就用一下 useCallback；这样会使代码的可读性大大降低。

如果页面的处理逻辑没那么复杂，可能这种父组件的频繁渲染不会有太大的问题。但是一旦页面的交互逻辑变得复杂，那么到那时候再去重构代码，是会非常痛苦的。

因此，为了使代码更加的 scalable，最好还是一开始就以最佳实践的形式去实现代码。

回到这个应用场景，如果不使用 useState 的状态参数传递，那么应该怎么做呢？实际上有两种解决方法。

## 使用 useImperativeHandle

我一开始的想法，其实就是通过某种方法调用 TextInput 组件内的函数，将子组件中的某个值传给父组件，进行进一步处理。

但是这种思路光凭回调函数无法实现，因为回调函数大多是在子组件中调用父组件中的某个函数，而无法在父组件中调用子组件的函数。

这时候，useImperativeHandle 就派上用场了。

简单来说，useImperativeHandle 就是通过一个 ref，将子组件中的函数暴露给外部（父）组件；这个 ref 是在父组件中定义的，通过参数的形式传给子组件。而子组件，则将参数中的 ref 作为 useImperativeHandle 的第一个参数，来和暴露的函数进行绑定。

```jsx
@label: useImperativeHandle的使用方法

import { useImperativeHandle } from 'react';

function MyInput({ ref }) {
  useImperativeHandle(ref, () => {
    return {
      // ... your methods ...
    };
  }, []);
  // ...
```

[useImperativeHandle – React](https://react.dev/reference/react/useImperativeHandle)

### 缺点？

尽管 useImperativeHandle 能够解决这个问题，但是这其实是一种命令式（Imperative）的写法，和 React 的声明式（Declarative）哲学不是非常契合。在某些情况下，这种单向数据流会使数据流变得混乱。

那么，有没有其它的方法呢？答案是有的。

### 封装复合组件

其实这个问题的本质，就是提交按钮的函数调用问题。如果将提交按钮和 TextInput 组件封装在一个「复合组件中」，就能很优雅地以声明式的方法解决这个问题。

当点击提交按钮之后，通过调用该复合组件的回调函数，来触发父组件中的相应处理逻辑；这样就能够大大减少父组件不必要的渲染，使代码更加 scalable。
