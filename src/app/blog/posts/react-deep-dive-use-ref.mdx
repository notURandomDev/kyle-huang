---
title: "useRef"
publishedAt: "2025-03-29"
tag: "React Deep Dive 系列"
image: "/images/gallery/react-deep-dive-cover.jpg"
---

## 应用场景

在处理对话功能的 SSE 数据时，会有两个不同类型的响应：

- **`type===’answer’`**：增量的回答文本；在每次接收到增量文本之后，都要使用 setState 更新 replyMessage。这不可避免地会频繁触发重渲染
- **`type===’reference’`**：推荐的「参考」数据。这部分的数据在响应全部完成之后，才会以「推荐气泡」的形式，展现在回复气泡下方，类似于主流 AI 聊天应用中的「推荐问题」气泡展示。

考虑到参考数据，即使不用立即进行展示，也需要将其进行暂时的存储，以便 SSE 事件完全结束后，使用回调函数访问该变量。

对于这种变量的临时存储，大多数情况下会使用 useState；因为 useState 的数据存在 Fiber 节点中，在组件重新渲染之后，数据不会被重置（memoizedState 存储）。

<br />
<Feedback
  title="为什么不直接使用变量？"
  description="如果该组件的重渲染频次很高，每次重渲染都会重置该变量的值（将其重新赋值），所以直接使用变量是达不到想要的效果的。"
/>
<br />

而使用 useState 进行跨生命周期数据存储的一个副作用就是，会触发组件的重新渲染。在大多数情况下，useState 这种副作用是理所应当的，因为这本身就是 useState 的设计初衷之一，即更新 UI 视图数据。

但是，如果错误使用 useState 的话，这种副作用就会导致不必要的重渲染；换言之，如果程序员的目的单纯是想要跨生命周期存储数据，并且不想在每次更新数据的时候都触发重渲染，那么这时候 useRef 就是最佳选择。

useRef 和其它的 hooks 不一样，在程序对其 current 的值进行更新的时候，不会触发调度更新。简单一点理解，就是 useRef 是 useState 的根源，useState 是在 useRef 之上多了一个「触发重渲染」的特性。可以理解为，useState 之于 useRef 就相当于包裹在 useEffect 中的函数和组件中的普通函数。
