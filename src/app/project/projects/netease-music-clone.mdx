---
name: "仿网易云音乐播放器小程序"
title: "开发一款仿网易云音乐的微信小程序"
publishedAt: "2025-07-02"
summary: "基于 React + Taro 框架构建的微信⼩程序⾳乐播放器，复刻⽹易云⾳乐的核⼼体验"
githubRepo: "netease-clone"
images:
  - "/images/projects/netease-music-clone/cover-01.jpg"
team:
  - name: "notURandomDev"
    role: "滚动歌词功能开发；播放器界面样式优化；个人信息相关界面重构；播放列表功能开发；全局状态设计；登录界面优化"
    avatar: "https://avatars.githubusercontent.com/u/126687028?s=64&v=4"
    github: "https://github.com/notURandomDev"
  - name: "WuJiaZhe123"
    role: "播放控件开发、处理播放器歌曲元信息获取"
    avatar: "https://avatars.githubusercontent.com/u/148238941?s=64&v=4"
    github: "https://github.com/WuJiaZhe123"
  - name: "WHS1145"
    role: "曲库界面、我的界面、搜索界面、歌曲组件等功能开发"
    avatar: "https://avatars.githubusercontent.com/u/168970481?s=64&v=4"
    github: "https://github.com/WHS1145"
  - name: "a-usre"
    role: "个人信息界面开发、登录界面开发"
    avatar: "https://avatars.githubusercontent.com/u/147981364?s=64&v=4"
    github: "https://github.com/a-usre"
---

## 项目简介

### 项目背景

这个项目是学校大三暑期短学期的「软件开发实践 3」课程（课程时间一周）项目，课程的要求是从给定的题目中选择一款小程序应用进行开发。其中，我们小组选择开发「音乐播放器小程序」，并决定以我们最常用的「网易云音乐 App」作为开发的参考，做一款「仿网易云音乐播放器小程序」。

由于项目周期短，我们挑选了核心的功能进行开发；同时简化了部分功能的实现。

### 小组分工

在评估了不同的系统设计方案之后，我们决定直接使用网易云音乐的 API 来获取歌曲详情、歌词、音频信息；同时人工收集了 50 首曲目 ID，来存储在本地的数据库中，简化后端的开发。

考虑到我们的方案大多是调用三方接口，因此后端的工作量比较小；而小程序的功能比较多，我们就分配了 4 位同学进行前端开发，1 位同学来开发后端。

### 前端技术栈

- 开发框架：由于我和一位同学对于 React 比较熟悉，另外两个同学一位有使用 Vue 的经验，另一位同学没有使用框架开发的经验；因此我们采用了适配 React 的 [Taro 框架](https://docs.taro.zone/docs/)
- 组件库：选择了对于 Taro 适配性较强的 [Taroify](https://taroify.github.io/taroify.com/introduce/)
- 全局状态管理工具：该小程序需要对播放列表中的曲目进行较为复杂的状态管理，使用了 [Zustand](https://zustand-demo.pmnd.rs/)

### 后端技术栈

使用了 SpringBoot + MyBatis + MySQL。

## 项目详情

### 项目介绍

本项⽬是⼀款基于 React + Taro 框架构建的微信⼩程序⾳乐播放器，致⼒于复刻⽹易云⾳乐的核⼼体验。

我们发现，尽管现有⾳乐 App 功能强⼤，但其⽇益臃肿的体积、复杂的操作以及版权分散等问题，让部分用户渴望⼀个更纯粹、更便捷的听歌⼊⼝。

### 功能介绍

- **用户登录**
  - ⽤户在⾸次登录⼩程序时，会被导航到登录界⾯。
  - 由于微信⼩程序⽀持通过 code、appId 和 appSecret ⾃动获取⽤户的 openid，点击此界⾯的「登录」按钮之后，实际上是通过 openid 在后端进⾏⾃动注册。
  - 我们使⽤了 zustand 做了全局状态的持久化缓存，这意味着⽤户在下⼀次使⽤⼩程序时，能够⾃动进⾏登录。
- **曲库界面**
  - 在曲库界⾯中，⽤户可以查看所有歌曲
- **曲目搜索**
  - 点击曲库⻚⾯上⽅的输⼊框后，会激活⼀个半透明的遮罩；⽤户可以输⼊搜索内容
- **搜索结果界⾯**
  - ⽤户输⼊搜索查询字符串之后，会导航到搜索结果界⾯，查看匹配的搜索结果
- **播放列表**
  - 点击播放列表中的歌曲，播放该曲⽬
  - 移除当前正在播放的歌曲，⾃动播放下⼀⾸
- **播放器-封⾯**
  - ⽑玻璃播放器背景：通过 backdrop-filter: blur(15px);实现沉浸式效果
  - 歌曲专辑封⾯展示：通过 songId 从⽹易云 API 获取专辑封⾯ URL
  - 歌曲信息展示：展示歌曲的歌名、歌⼿等元数据
  - 歌曲收藏功能：点击 ❤️ 按钮之后，能够对歌曲进⾏收藏 / 取消收藏
- **播放器-滚动歌词**
  - 滚动歌词：在歌曲播放过程中，歌词能够实现⾃动滚动
  - 歌词定位器：⾼亮展示当前正在播放的歌词⾏；⽀持⽤户拖动歌词进⾏歌曲
  - 歌曲进度展示：进度条监听歌曲当前的进度，同时⽀持⽤户通过点击、拖拽进度条来实现歌曲进度的定位进度的定位功能
  - 播放控件：实现歌曲的播放、暂停，以及进⾏上⼀⾸/下⼀⾸的切歌功能
- **我的界面**
  - 除了展示⽤户的头像和昵称之外，我的界⾯中还有⼀个「我的喜欢」歌曲列表，展示⽤户收藏的歌曲。
  - ⽤户信息展示组件：点击⽤户头像之后，可以跳转⾄⽤户信息修改界⾯，进⾏个⼈信息的编辑。
- **喜欢曲目**
  - 下⼀⾸播放：将该曲⽬添加到播放列表中，会在当前播放歌曲的下⼀⾸进⾏播放
  - 取消喜欢：点击取消喜欢，能够将该歌曲从「我喜欢的」歌曲列表中移除
- **个人信息修改**
  - 个人档案信息、昵称修改、简介修改

## 我的收获

在这个项目中，我的主要任务就是进行播放器界面的开发和系统架构的设计。其中，功能开发包括 播放详情 和 滚动歌词 两个界面；我认为滚动歌词功能是我在开发这个项目中遇到最大的挑战。

### 全局状态管理

在之前做过的项目中，我其实没怎么使用过全局状态管理；使用到的状态基本都是页面组件的 local state。

但是在这个项目中，由于在多个视图中都要同步当前播放器播放曲目的数据，因此使用 local state 肯定行不通，因为要进行 props drilling。

于是，这个项目就采用了 Zustand 作为全局状态管理的工具；加上 persist 中间件，实现了全局状态和小程序缓存的无缝集成。除了播放器数据使用全局状态管理之外，播放列表数据和用户数据也都通过 Zustand 进行管理。

在我看来，全局状态不但能使功能之间解耦；其另一很关键的作用，就是能使开发变得更加模块化。其实全局状态管理，在某种程度上是一种单例思想的体现。开发者可以在一个地方统一处理某一全局状态的方法、属性，规定了一个使用的范式；这样就避免了协同开发者在 callsite 使用不规范的方式更新状态。当然，这两者是相辅相成的。

这意味着全局状态的设计的非常重要的，而且这项工作必须在时间上优先于具体功能的开发；因为全局状态相当于不同功能之间的交集，是被功能所依赖的。

平心而论，我觉得自己在这个项目中设计的全局状态方法，特别是 **播放器** 相关状态的方法，设计的有缺陷。

就比如说，对于歌曲继续播放 **resume** 这个方法中，除了封装了使播放器播放的方法 **player.play()**，还进行了将当前播放状态设置成 **true** 的操作。而由于这个方法是在开发的中后期，遇到和音频相关功能时才加上的，导致一度 debug 了很久，为什么歌曲播放的状态标志，和音频实际是否在播放为什么对不上。之后才发现，是之前未引入该方法的时候，在另外一个地方已经 toggle 了播放的状态位。

总而言之，这个项目让我大量接触了全局状态管理的使用，对其使用方法有很多感悟。

### 滚动歌词功能的实现

滚动歌词其实算是这个项目中的一个亮点功能。在该视图中，随着歌曲进度条的推移，当前时刻音频对应的歌词会自动滚动到聚焦的中心。除此之外，用户还可以通过拖动歌词，定位到歌词所对应的歌曲进度。

![](/images/projects/netease-music-clone/image-01.jpg)

.lrc 歌词文件是这个功能实现的基础，通过网易云音乐 API 可以获取到特定 ID 歌曲的歌词文件；这个文件的特点就是在每句歌词之前有相应的时间戳数据，这样滚动歌词的视图在获取到该歌词文件之后，就能将数据映射成界面中的歌词元素。

歌词在歌曲播放过程中自动滚动的功能，使用了 Taro 中 ScrollView 的 scrollTop API；实现的主要思路就是在播放歌曲的时候监听歌曲的进度，然后动态更新 ScrollView 的 scrollTop，来实现滚动的效果。

<Accordion title="💡 scrollTop API 的原理是什么？" open>
  <Text onBackground="neutral-weak">
    scrollTop
    表示当前容器顶部内容被隐藏的高度，即顶部内容的偏移量。通过动态更新这个值，就能够实现自动拖动容器滚动条的效果。
  </Text>
</Accordion>

而滚动歌词视图中央歌词定位器，其实就是一个能够显示和隐藏的绝对定位元素。当用户在拖动歌词的时候，将控制定位器显隐的状态进行更新，就能使歌词定位器高亮，反之亦然。

对于如何将当前正在播放的歌词行置于视图中央，并在歌词定位器左侧显示当前歌词所对应歌曲时刻的逻辑，也包含了一定的巧思。具体思路则是通过获取到当前活跃歌词行下标所对应元素的 top 和 height 属性，并将 `const newScrollTop = top + height / 2;` 的计算结果赋值给 scrollTop 来实现的。

<Accordion title="💡 如何获取活跃歌词行？" open>
  <Text onBackground="neutral-weak">
    其实很简单。监听当前播放歌曲时刻的同时，遍历整个由 LRC
    文件解析出来的歌词数组，将当前播放歌曲的 currentTime
    和数组中的数据进行对比；起始时间小于
    currentTime，并且下一句歌词的起始时间大于 currentTime
    的那句歌词，就是当前活跃的歌词！
  </Text>
</Accordion>

所有歌词元素的维度数据，则是在视图渲染完成之后，存储在一个数组中，来实现后续通过下标进行访问的。

<CodeBlock
  marginBottom="16"
  codes={[
    {
      code: `
const getLyricDimensions = () => {
  Taro.createSelectorQuery()
    .selectAll(".lyric-line")
    .boundingClientRect((rects) => {
      if (!Array.isArray(rects)) return;
      const dims = rects
        .filter((r) => r)
        .map(({ top, height }) => ({ top: top - 330, height }));
      setLyricsDimensions(dims);
    })
    .exec();
};
  
`,
      language: "jsx",
      label: "获取所有歌词元素维度数据的函数",
    },
  ]}
/>

还有一个细节功能，就是当前播放歌词自动吸附到视图中央的实现；即当歌曲正在播放时，如果用户对歌词拖拽了一定的偏移量之后一小段时间，视图会自动将正在播放的歌词吸附到视图正中央（歌词定位器的位置）。这个功能其实还是借助了 scrollTop 的 API，在歌词定位器隐藏时将 scrollTop 设置成与当前播放歌词相匹配的位置。

这里的中心歌词定位器的显隐控制，其实又有很多文章。正常来说是通过 ScrollView 的 onScrollEnd API 来实现的，但是 Taro 提供的 ScrollView 并没有这个 API。为了实现相同的功能，我只能在 onScroll API 上结合防抖函数来模拟 onScrollEnd API。

### debounce 模拟 onScrollEnd API

由于 Taro 的 ScrollView 组件没有提供 onScrollEnd API，而歌词定位器的显隐又需要通过**用户拖动视图结束事件**来控制；因此，就需要在 onScroll API 之上，进行 onScrollEnd 事件的模拟。

在有 onScrollEnd API 的前提下，控制歌词定位器显隐的思路就是在 onScrollEnd 事件被触发时，用一个 setTimeout 回调函数来延迟 toggle `centerIndicatorVisible` 的值。

有了这个基准思路，模拟 onScrollEnd API 的逻辑其实就是在 onScroll 的响应函数 handleScroll 中，添加想通过 onScrollEnd 来实现的逻辑。

<CodeBlock
  marginBottom="16"
  codes={[
    {
      code: `
const handleScroll = (e: BaseEventOrig<ScrollViewProps.onScrollDetail>) => {
  if (!isScrollingRef.current) {
    isScrollingRef.current = true;
    setCenterIndicatorVisible(true);
  }
  debouncedOnScrollEnd(); // onScrollEnd 处理的逻辑
  // onScroll 处理的逻辑
};
  
`,
      language: "tsx",
      label: "简化后的 handleScroll 代码",
    },
  ]}
/>

可以看到，封装 onScrollEnd 触发逻辑的函数，在 onScroll 事件每次被触发的时候都会调用。这肯定是不合理的，因为 **onScroll 事件触发的频率** >> **onScrollEnd 事件触发的频率**。

因此，需要使用防抖函数的特性；即使该外层函数 `debouncedOnScrollEnd` 仍是被频繁触发，debounce 内的回调函数只有在触发间隔大于 500ms 的那一次事件上才会被调用。

<CodeBlock
  marginBottom="16"
  codes={[
    {
      code: `
const debouncedOnScrollEnd = useMemo(
() =>
    debounce(() => {
    isScrollingRef.current = false;
    setCenterIndicatorVisible(false);
    }, 500),
[]
);

`,
language: "tsx",
label: "500ms 并不一定是模拟的最佳数值，但是是可以接受的效果",
},
]}
/>

当然，通过防抖来模拟的 onScrollEnd API，无法做到完美还原。这是因为 scroll 行为本身是有一个惯性的特点，即使手指不再拖动屏幕，ScrollView 的内容仍有可能由于滚动的惯性而继续滚动；而这一行为是难以通过 debounce 的 wait 数值来预测持续时间的。
