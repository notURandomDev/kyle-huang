---
name: "LarkClone"
title: "开发一个支持多构建系统、混合技术栈的仿飞书App"
publishedAt: "2025-05-22"
summary: "业务层使用 Swift + Objective-C 进行原生开发，RustSDK 进行数据通信&存储的底层能力实现。"
githubRepo: "LarkClone"
images:
  - "/images/projects/lark-clone/cover-01.jpg"
  - "/images/projects/lark-clone/cover-02.jpg"
  - "/images/projects/lark-clone/cover-03.jpg"
  - "/images/projects/lark-clone/cover-04.jpg"
team:
  - name: "notURandomDev"
    role: "仓库Owner；消息界面开发；架构设计；RustSDK开发、FFI集成；xcodebuild迁移"
    avatar: "https://avatars.githubusercontent.com/u/126687028?s=64&v=4"
    github: "https://github.com/notURandomDev"
  - name: "Cato3o"
    role: "消息二级界面、邮箱和邮件界面开发；测试编写"
    avatar: "https://avatars.githubusercontent.com/u/132040478?s=64&v=4"
    github: "https://github.com/Cato3o"
  - name: "lazychih114"
    role: "Bazel构建系统迁移"
    avatar: "https://avatars.githubusercontent.com/u/57559734?s=64&v=4"
    github: "https://github.com/lazychih114"
---

## 项目背景

这个项目是我参加「字节跳动-飞书客户端技术训练营」时，我们组导师发布的课题项目；内容是开发一个简易的仿飞书 App。

## 用到的技术

我们导师对这个项目中使用的技术栈，提出了以下要求：

- UI 部分使用 Swift、OC 开发
- 底层数据服务使用 Rust 开发
- Swift、OC 与 Rust 使用 protobuf 通信
- 支持 xcodebuild、bazel 两套构建系统

## 核心功能

在和团队经过了近一个月的开发之后，我们组项目的成品具有以下核心功能：

### Lark Messenger ｜ 飞书消息界面

通过 `dequeueReusableCell(withIdentifier:)` 复用已滚出屏幕的单元格，避免重复创建和销毁，大幅提升列表滚动性能。未显示的单元格会被放入「复用池」，需要时直接取出重置内容。

- 支持上拉加载更多
- 支持在二级聊天页面中模拟消息的查看、发送

### Lark Mail ｜ 飞书邮箱界面

- 支持「未读、含附件、全部邮件」的筛选
- 支持关键字搜索
- 支持邮件的删除

### 多语言支持

通过 `Localizable.strings` 存储多语言文本，使用 `NSLocalizedString()` 动态加载，结合系统语言设置自动切换显示。

### 系统主题色自适应

通过系统语义化颜色自动适配 Light/Dark 模式。

### 设备尺寸自适应

通过约束（Constraints）定义视图的相对关系，自动计算布局，适配不同屏幕尺寸和方向变化。

## 遇到的挑战 & 学到的东西

在加入这个训练营之前，我做的项目使用的都是 Web 开发的技术栈；比较擅长使用 JS、TS 进行应用的快速迭代，覆盖了 Web（React.js）和移动端的跨平台开发（React Native）。

由于我没有接触过客户端的原生开发，所以一开始看到课题的时候，还是觉得蛮吓人的。因为 Swift、OC、Rust，都是我之前没有接触过的语言；对构建系统也不了解，更别说听都没听过的 protobuf。在不到一个月的时间内，需要从 0 开始学习这些技术、开发到最后的交付，是非常有挑战的一件事情。

但是在开发的过程中，特别是接触了原生的开发之后，我发现自己对于建立于原生代码上的跨平台开发有了全新的认知；我找到了这两者之间的联系：

- 通过学习原生开发，我了解了跨平台框架实现的底层原理；在原生开发过程中遇到的系统 API ，使我对于 iOS 客户端的特性有了更深刻的了解
- 而反过来，我又意识到跨平台框架为开发者提供了许多便利，相较于原生开发能够显著地提升开发效率

## 项目总结

我们组的项目最终以超出导师预期的效果通过了验收。在开发过程中，我贡献了不少产出；最后也是幸运地拿到了飞书移动端架构组 ByteIntern 的实习 Offer ～

### 大型 App 架构的复现

在飞书实习了一段时间之后，回过头来看这个项目；发现 LarkClone 的开发过程，其实就是飞书 App 本身发展历程的一个缩影。

在技术栈方面；飞书 App 采用的就是各端 UI 层使用原生开发，底层复用 RustSDK 提供的各端通用数据通信、存储能力；这种模式能带来很多好处。

UI 层原生开发使各端能够充分利用其 OS 的特性。尽管这意味着各端需要维护一套代码，但是对于飞书这种对于性能要求高的大型项目而言反而是最合适的。

- 一方面，飞书的功能复杂多样；使用跨平台开发很容易遇到性能瓶颈，而且功能对各端 OS 的特性依赖越强，跨平台代码的维护成本就越高
- 另一方面，字节跳动这种大厂完全有开发和维护原生 App 的资本

底层数据通信、存储代码的复用则为业务逻辑提供了强一致性。

在架构设计方面，RustSDK 和各端代码之间通过 FFI 的集成是团队花了很多精力解决的问题；而采用 protobuf 进行数据通信，也是实现性能极致优化的关键基础。

在构建系统方面，飞书 App 本身也是经历了从 xcodebuild、cargo 迁移到 Bazel 构建系统的过程。前者与开发技术栈高度适配的特性为 App 初期的快速迭代开发提供了便利，后者则是项目规模不断扩大之后，为了提升研发效率的必然选择。

### 写在最后

对我来说，LarkClone 是一个非常有价值的项目。

除了为我获得到字节跳动实习机会之外，LarkClone 给我带来了开发认知上的一次巨大转折。这个项目让我从大学中课程项目、以及个人项目中采用的简单架构思维，转变到了真实企业规模 SaaS 的复杂且高效的架构设计思维。

这里要特别感谢字节的导师在项目过程中，对于我提出的各种疑问的及时解答。他作为一个企业中，对飞书项目有深刻理解的工程师所提供的视角；对于我的理解提供了很实用的帮助。

同时，在 LarkClone 开发中遇到各种难题时进行的思考，帮助了我更加平滑地 Landing 实习；也为我后续在飞书团队中接手的工作减少了很多理解成本。
